//
// Starting with a CSV file generated by diskimage.js; eg:
//
//    node diskimage.js --all="*.{ZIP,ARC}" --list=csv >> archives.csv
//
// this produces archives#.csv files with the following fields:
//
//      archiveID,name,messages,comment
//
// and files#.csv files with the following fields:
//
//      fileID,archiveID,hash,modified,attr,size,compressed,method,name,messages,comment
//
// Each file is limited to 500,000 lines to help ensure the data can be imported into a database
// via phpmyadmin (or other tool) without running into out-of-memory or time-out issues.
//
import fs from "fs";

let args = process.argv.slice(2);
let i = 0;
let csvFile = args[i++];
if (!csvFile) {
    console.log("Usage: node split.js <csvfile>");
    process.exit(1);
}

let lines = [];
let bufferSize = 1024 * 1024; // 1MB
let buffer = Buffer.alloc(bufferSize);
let leftover = "";
let fd = fs.openSync(csvFile, "r");

while (true) {
    let bytesRead = fs.readSync(fd, buffer, 0, bufferSize, null);
    if (!bytesRead) break;
    let chunk = leftover + buffer.toString("utf-8", 0, bytesRead);
    let chunkLines = chunk.split('\n');
    leftover = chunkLines.pop();
    for (let line of chunkLines) {
        lines.push(line.replace(/\r$/, ''));
    }
}
if (leftover) {
    lines.push(leftover.replace(/\r$/, ''));
}
fs.closeSync(fd);

//
// Every line of the input CSV should have the following fields:
//
//      hash,modified,attr,size,compressed,method,path,messages,comment
//
// unless the line continues the previous line's "comment" field (since they can be multi-line).
//
// For every line that begins with a 32-bit "hash", 19-char "modified" date and time, and
// decimal "attr", "size", and "compressed" values, we will extract the name of the archive
// from the "path" field (everything up to but not including the first colon), record that
// as the active archiveName and increment archiveID.  Then we will increment fileID and write
// the following fields to an files#.csv file:
//
//      fileID,archiveID,hash,modified,attr,size,compressed,method,fileName,messages,comment
//
// where "fileName" is the everything in the original "path" after the colon.  This line must then
// be followed by every line that does NOT begin with the above values (ie, hash, modified, etc).
//
// Once we have written 500000 lines to our output buffer, we flush the buffer to files#.csv
// and empty the buffer.
//
// At the same time, every time we encounter a new archiveName, we will write the following fields
// to an archives#.csv file:
//
//      archiveID,archiveName,messages,comment
//
// And as above, this line must be followed by every line that does NOT begin with the above fields,
// and once we have buffered 500000 lines, we write them to archives#.csv file and flush the buffer.
//

let nFiles = 0;
let nArchives = 0;
let nMaxLines = 500000;
let archiveLines = [];
let fileLines = [];
let archiveName = "", archiveMode = false;
let archiveID = 10000000, fileID = 20000000;
let longestFileName = 0, longestArchiveName = 0, longestMethod = 0, longestMessage = 0;

let iLine = 1;
for (let line of lines) {

    let match = line.match(/^([a-z0-9-]{32}|),(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}|),(\d+|),(-?\d+|),(-?\d+|),([^,]+|),(.*)$/);
    if (match) {
        //
        // The final capture group contains the path, messages, and comment, but all we need from it is the path,
        // which may be quoted and may contain commas.
        //
        let hash = match[1];
        let modified = match[2];
        let attr = match[3];
        let size = match[4];
        let compressed = match[5];
        let method = match[6];
        if (method.length > longestMethod) longestMethod = method.length;
        let fullPath, remainder = match[7];
        //
        // TODO: This first match takes care of a bug in diskimage.js where it didn't properly
        // quote the combination of parent and file (it only quoted file).
        //
        match = remainder.match(/^([^":]+):"([^"]+)",(.*)$/);
        if (match) {
            fullPath = match[1] + ":" + match[2];
            remainder = match[3];
        } else {
            match = remainder.match(/^"([^"]+)",(.*)$/);
            if (match) {
                fullPath = match[1];
                remainder = match[2];
            } else {
                match = remainder.match(/^([^,]*),(.*)$/);
                if (match) {
                    fullPath = match[1];
                    remainder = match[2];
                } else {
                    console.log(`unable to parse path in line ${iLine}: ${line}`);
                }
            }
        }
        match = remainder.match(/^"([^"]+)"/);
        if (match) {
            let message = match[1];
            if (message.length > longestMessage) longestMessage = message.length
        }
        //
        // Fix CSV output on archive-level (as opposed to entry-level) errors; diskimage.js should be fixed now,
        // but this hack is for existing CSV files that have already been generated.
        //
        if (remainder.match(/^"[^"]*"$/)) {
            remainder += ",";
        }
        let archiveNext = fullPath.split(":")[0];
        if (archiveName != archiveNext) {
            archiveName = archiveNext;
            if (archiveName.length > longestArchiveName) longestArchiveName = archiveName.length;
            //
            // Before we push another line, if we've reached nMaxLines, let's write what we've got.
            //
            if (archiveLines.length >= nMaxLines) {
                let archiveCSV = `archives${++nArchives}.csv`;
                console.log(`writing ${archiveCSV}...`);
                fs.writeFileSync(archiveCSV, archiveLines.join("\n"));
                archiveLines = [];
            }
            let name = archiveName;
            if (name.indexOf('"') >= 0) {
                name = name.replace(/"/g, '""');
            }
            if (name.indexOf(',') >= 0) {
                name = `"${name}"`;
            }
            archiveLines.push(`${++archiveID},${name},${remainder}`);
            archiveMode = true;
        }
        else if (fullPath == archiveName || fullPath.indexOf(':') < 0) {
            console.log(`skipping line ${iLine}: ${line}`);
        }
        else {
            let fileName = fullPath;
            if (fileName.indexOf(':') < 0) {
                //
                // This can happen when a processing error occurs in the middle of an archive,
                // and we don't actually know what file was being processed.
                //
            } else {
                fileName = fileName.split(":")[1];
            }
            if (fileName[0] == '/') fileName = fileName.slice(1);
            if (fileName.length > longestFileName) longestFileName = fileName.length;
            //
            // Before we push another line, if we've reached nMaxLines, let's write what we've got.
            //
            if (fileLines.length >= nMaxLines) {
                let fileCSV = `files${++nFiles}.csv`;
                console.log(`writing ${fileCSV}...`);
                fs.writeFileSync(fileCSV, fileLines.join("\n"));
                fileLines = [];
            }
            //
            // NOTE: While my original intention was to only include fileName (not fullPath) in files#.csv
            // (because it wastes space), it's more convenient to have it all in one place... for now.
            //
            let name = fullPath;
            if (name.indexOf('"') >= 0) {
                name = name.replace(/"/g, '""');
            }
            if (name.indexOf(',') >= 0) {
                name = `"${name}"`;
            }
            fileLines.push(`${++fileID},${archiveID},${hash},${modified},${attr},${size},${compressed},${method},${name},${remainder}`);
            archiveMode = false;
        }
    }
    else {
        if (line.match(/^(warning: |error: )/)) {
            console.log(`skipping line ${iLine}: ${line}`);
        } else {
            if (!archiveMode) {
                fileLines.push(line);
            } else {
                archiveLines.push(line);
            }
        }
    }
    iLine++;
}

if (archiveLines.length) {
    let archiveCSV = `archives${++nArchives}.csv`;
    console.log(`writing ${archiveCSV}...`);
    fs.writeFileSync(archiveCSV, archiveLines.join("\n"));
}

if (fileLines.length) {
    let fileCSV = `files${++nFiles}.csv`;
    console.log(`writing ${fileCSV}...`);
    fs.writeFileSync(fileCSV, fileLines.join("\n"));
}

console.log(`longest file name: ${longestFileName}`);
console.log(`longest archive name: ${longestArchiveName}`);
console.log(`longest method: ${longestMethod}`);
console.log(`longest message: ${longestMessage}`);
