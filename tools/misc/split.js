//
// Starting with a CSV file generated by diskimage.js; eg:
//
//    node diskimage.js --all="*.{ZIP,ARC}" --list=csv >> archives.csv
//
// this produces archives-#.csv files with the following fields:
//
//      archiveID,name,messages,comment
//
// and files-#.csv files with the following fields:
//
//      fileID,archiveID,hash,modified,attr,size,compressed,method,name,messages,comment
//
// Each file is limited to 500,000 lines to help ensure the data can be imported into a database
// via phpmyadmin (or other tool) without running into out-of-memory or time-out issues.
//
import fs from "fs";

let args = process.argv.slice(2);
let i = 0;
let csvFile = args[i++];
if (!csvFile) {
    console.log("Usage: node split.js <csvfile>");
    process.exit(1);
}

let lines = [];
let bufferSize = 1024 * 1024; // 1MB
let buffer = Buffer.alloc(bufferSize);
let leftover = "";
let fd = fs.openSync(csvFile, "r");

while (true) {
    let bytesRead = fs.readSync(fd, buffer, 0, bufferSize, null);
    if (!bytesRead) break;
    let chunk = leftover + buffer.toString("utf-8", 0, bytesRead);
    let chunkLines = chunk.split('\n');
    leftover = chunkLines.pop();
    for (let line of chunkLines) {
        lines.push(line.replace(/\r$/, ''));
    }
}
if (leftover) {
    lines.push(leftover.replace(/\r$/, ''));
}
fs.closeSync(fd);

//
// Every line of the input CSV (well, that we care about) should have the following fields:
//
//      hash,modified,attr,size,compressed,method,path,messages,comment
//
// unless the line continues the previous line's "comment" field (since they can be multi-line).
//
// For every line that begins with a 32-bit "hash", 19-char "modified" date and time, decimal
// "attr", "size", and "compressed" values, and a "method" string, we extract the name of the
// archive from the remainder of the line (ie, everything up to but not including the first
// colon of "path").  We then record that name as the current archiveName and increment archiveID.
//
// Every time we encounter a new archiveName, we push a line with the following fields to the
// archiveLines array:
//
//      archiveID,archiveName,messages,comment
//
// We then increment fileID and push a line with the following fields to the fileLines array:
//
//      fileID,archiveID,hash,modified,attr,size,compressed,method,fileName,messages,comment
//
// where fileName is the everything in the original "path" after the colon.  This line must then
// be followed by every line that does NOT begin with the above values (ie, any comment lines that
// follow it).
//
// Once we have pushed 500000 lines to fileLines, we write them to files-#.csv and empty the array;
// ditto for archiveLines, which is written to archives-#.csv.
//

let nFiles = 0;
let nArchives = 0;
let nMaxLines = 500000;
let archiveLines = [];
let fileLines = [];
let archiveName = "", archiveMode = false;
let archiveID = 10000000, fileID = 20000000;
let longestFileName = 0, longestArchiveName = 0, longestMethod = 0, longestMessage = 0;

let iLine = 0;
for (let line of lines) {
    iLine++;
    let match = line.match(/^([a-z0-9-]{32}|),(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}|),(\d+|),(-?\d+|),(-?\d+|),([^,]+|),(.*)$/);
    if (match) {
        //
        // The final capture group contains the remainder (ie, path, messages, and comment).
        //
        let hash = match[1];
        let modified = match[2];
        let attr = match[3];
        let size = match[4];
        let compressed = match[5];
        let method = match[6];
        if (method.length > longestMethod) longestMethod = method.length;
        let fullPath, remainder = match[7];
        //
        // This regex is intended to capture either a quoted OR unquoted path; note that either form is
        // permitted to contain quotes (but only the '""' double-double-quote variety), and only the former
        // is permitted to contain commas.
        //
        // It also captures the remainder of the line, which becomes the new remainder (messages and comment).
        //
        let matchPath = remainder.match(/^(?:"(.*?[^"])",|([^,]*),)(.*)$/);
        if (matchPath) {
            //
            // That regex always returns the first capture group in matchPath[1] and the second capture
            // group in matchPath[2], and since they both can't be true, one of them will always be undefined.
            //
            fullPath = matchPath[1] || matchPath[2];
            remainder = matchPath[3];
        } else {
            console.log(`unable to parse path in line ${iLine}: ${line}`);
            archiveMode = null;
            continue;
        }
        let matchMessage = remainder.match(/^"([^"]+)"/);
        if (matchMessage) {
            if (matchMessage[1].length > longestMessage) longestMessage = matchMessage[1].length;
        }
        let archiveNext = fullPath.split(":")[0];
        if (archiveName != archiveNext) {
            archiveName = archiveNext;
            if (archiveName.length > longestArchiveName) longestArchiveName = archiveName.length;
            //
            // Before we push another line, if we've reached nMaxLines, let's write what we've got.
            //
            if (archiveLines.length >= nMaxLines) {
                let archiveCSV = `archives-${++nArchives}.csv`;
                console.log(`writing ${archiveCSV}...`);
                fs.writeFileSync(archiveCSV, archiveLines.join("\n"));
                archiveLines = [];
            }
            let name = archiveName;
            if (name.indexOf('"') >= 0) {
                name = name.replace(/"/g, '""');
            }
            if (name.indexOf(',') >= 0) {
                name = `"${name}"`;
            }
            archiveLines.push(`${++archiveID},${name},${remainder}`);
            archiveMode = true;
        }
        else if (fullPath == archiveName || fullPath.indexOf(':') < 0) {
            //
            // We could try to update the original archiveLine with any new message info,
            // but it's easier to just re-record the line with a different archiveID.
            //
            archiveLines.push(`${++archiveID},${fullPath},${remainder}`);
            archiveMode = null;
        }
        else {
            let fileName = fullPath;
            if (fileName.indexOf(':') < 0) {
                //
                // This can happen when a processing error occurs in the middle of an archive,
                // and we don't actually know what file was being processed.
                //
            } else {
                fileName = fileName.split(":")[1];
            }
            if (fileName[0] == '/') fileName = fileName.slice(1);
            if (fileName.length > longestFileName) longestFileName = fileName.length;
            //
            // Before we push another line, if we've reached nMaxLines, let's write what we've got.
            //
            if (fileLines.length >= nMaxLines) {
                let fileCSV = `files-${++nFiles}.csv`;
                console.log(`writing ${fileCSV}...`);
                fs.writeFileSync(fileCSV, fileLines.join("\n"));
                fileLines = [];
            }
            //
            // NOTE: While my original intention was to only include fileName (not fullPath) in files-#.csv
            // (because it wastes space), it's more convenient to have it all in one place... for now.
            //
            let name = fullPath;
            if (name.indexOf('"') >= 0) {
                name = name.replace(/"/g, '""');
            }
            if (name.indexOf(',') >= 0) {
                name = `"${name}"`;
            }
            fileLines.push(`${++fileID},${archiveID},${hash},${modified},${attr},${size},${compressed},${method},${name},${remainder}`);
            archiveMode = false;
        }
    }
    else {
        if (line.match(/^(warning: |error: )/)) {
            console.log(`skipping line ${iLine}: ${line}`);
        } else if (archiveMode !== null) {
            if (!archiveMode) {
                fileLines.push(line);
            } else {
                archiveLines.push(line);
            }
        }
    }
}

if (archiveLines.length) {
    let archiveCSV = `archives-${++nArchives}.csv`;
    console.log(`writing ${archiveCSV}...`);
    fs.writeFileSync(archiveCSV, archiveLines.join("\n"));
}

if (fileLines.length) {
    let fileCSV = `files-${++nFiles}.csv`;
    console.log(`writing ${fileCSV}...`);
    fs.writeFileSync(fileCSV, fileLines.join("\n"));
}

console.log(`longest file name: ${longestFileName}`);
console.log(`longest archive name: ${longestArchiveName}`);
console.log(`longest method: ${longestMethod}`);
console.log(`longest message: ${longestMessage}`);
